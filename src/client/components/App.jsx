import axios from 'axios';
import _ from 'lodash';
import uuidV1 from 'uuid/v1';
import React, { Component } from 'react';
import { render } from 'react-dom';

import Console from './Console';
import linkedList from '../linkedList'; // imports a new linkedList data structure

class App extends Component {

	constructor(props) {
		super(props);

		/*
		 * @name: state
		 * @purpose:
		 *  `.current`        : instance of the linkedList that represents the current command prompt
		 *  `.currentText`    : an object that tracks the entire current line (`1 + 3 + 4`) as well 
		 *		                  as a unique id that is associated with that line.
		 *  `.consoleIsActive`: boolean tracking whether the last click was in the console or not.
		 *  `.currentKey`     : a string that is the `id` property of the current character of the command
		 *                      line.
		 *  `.history`        : Array holding all entered commands
		 *	`.currentIndex`   : the index of the current command-line in respect to the history array
		 *  `.focus`          : the character value at the `currentKey` id in the `.current` linkedList instance
		 * 	`.left`           : String of all characters left to the `.focus` character
		 *  `.right`          : String of all characters right to the `.focus` character`
		 */

		this.state = {
			current: new linkedList(),
			currentText: '', 
			consoleIsActive: false, 
			currentKey: '',
			currentIndex: 0,
			left: '',
			right: '',
			focus: '',
			history: [],
		};

		// set bindings for in-function calls
		this._addLinkedListText = this._addLinkedListText.bind(this);
		this._handleKeyPress = this._handleKeyPress.bind(this);
		this._handleKeyDown = this._handleKeyDown.bind(this);
		this._setConsoleIsActive = this._setConsoleIsActive.bind(this);
		this._deleteCurrentLinkedList = this._deleteCurrentLinkedList.bind(this);
		this._generateUniqueKey = this._generateUniqueKey.bind(this);
		this._makeCopy = this._makeCopy.bind(this);
		this._updateState = this._updateState.bind(this);
		this._updateCurrentText = this._updateCurrentText.bind(this);
		this._setRightLeft = this._setRightLeft.bind(this);
		this._processCode = this._processCode.bind(this);
		this._clearConsole = this._clearConsole.bind(this);
		this._setHistory = this._setHistory.bind(this);
		this._cycleHistory = this._cycleHistory.bind(this);
		this._updateIndex = this._updateIndex.bind(this);
	}

	/*
	 * @name: _makeCopy
	 * @input: the value for this.state.current -- or the current linkedList instance
	 * @output: a copy of the current linkedList instance
	 * @purpose: to make a copy of the current linkedList instance
	 */
	_makeCopy(current) {
		let protoCopy = Object.create(current.__proto__);
		let propertyCopy = Object.assign(protoCopy, current);
		return propertyCopy;
	}

	/*
	 * @name: _generateUniqueKey
	 * @input: n/a
	 * @output: a unique segment of strings generated by the `uuidV1` npm package
	 * @purpose: to generate a unique id that'll be used for the character entered
	 */
	_generateUniqueKey() {
		return uuidV1();
	}

	/*
	 * @name: _handleKeyPress
	 * @input: the keyPress event 
	 * @output: n/a
	 * @purpose: an event-listener that is listening for when the keys the user presses.
	 *   If it has a length that is 1, and the last mouse click of the user was within the
	 *   console, then it'll also run the `_addLinkedListText` method. 
	 */
	_handleKeyPress(e) {
		// reason why we have `.length` is to ignore other `e.key` values like: `Enter`
		e.key.length === 1 && this.state.consoleIsActive && this._addLinkedListText(e.key);
	}

	/*
	 * @name: _setRightLeft
	 * @input: a copy of the linkedList instance made from `_makeCopy`
	 * @output: n/a
	 * @purpose: updates the component's `._left`, `._right`, and `._focus` state properties. 
	 *   Remember that the `._left` contains all the characters left of the
	 *   cursor, while `._right` contains all the characters right of the cursor.
	 *   character at the cursor is at the `._focus` property
	 */
	_setRightLeft(copyOfCurrent) {
		this.setState({
			left: copyOfCurrent._left,
			right: copyOfCurrent._right,
			focus: copyOfCurrent._focus,
		});
	}

	/*
	 * @name: _setRightLeft
	 * @input: a boolean that denotes whether the user clicked left or right. 
	 * @output: n/a
	 * @purpose: As the user hits the right and left arrow keys, we need to be
	 *   able to adjust the key they highlighted. This method does that by:
	 *     1. Make a copy of the current linkedList instance
	 *     2. Get the node of where the user is currently at
	 *     3. Once found, appropriately set the next node to be `.previous` or `.next`
	 *     4. Reset the `._focus` property of the linkedList instance to either 
	 *          the node of the `.previous` or the `.next`
	 *     5. Update the `._left`, `._right`, `._focus` properties and the `currentKey`
	 *   
	 */
	_determineRightLeft(leftOrRight) {
		// true is left
		let copyOfCurrent = this._makeCopy(this.state.current);
		let nextId = leftOrRight ? 
			copyOfCurrent.getNode(this.state.currentKey).previous.value.id :
			copyOfCurrent.getNode(this.state.currentKey).next.value.id;

		// updates the instance's ._left, ._right, ._focus properties
		copyOfCurrent.returnAllRightLeft(nextId);

		// resets the local states' ._left / ._right / ._focus
		this._setRightLeft(copyOfCurrent);

		// adjusts the .currentKey property
		this.setState({
			currentKey: nextId
		});
	}

	/*
	 * @name: _clearConsole
	 * @input: n/a
	 * @output: n/a
	 * @purpose: clears the console by resetting the local state while also incrementing
	 *   `currentIndex` property
	 */
	_clearConsole() {
		this.setState({
			current: new linkedList(),
			currentText: '',
			currentKey: '', // the KEY per each letter
			currentIndex: this.state.currentIndex + 1, // could update by _updateIndex
			left: '',
			right: '',
			focus: '',
		});
	}

	/*
	 * @name: _setHistory
	 * @input: an array that contains the history of what the user typed
	 * @output: n/a
	 * @purpose: updates the local history array.
	 */
	_setHistory(history) {
		this.setState({
			history: history
		});
	}

	/*
	 * @name: _processCode
	 * @input: n/a
	 * @output: n/a
	 * @purpose: makes a post request to the backend with the code to be `eval`-ed
	 *  on the body of the POST request. Once the response is received, we add it
	 *  it into our `history` state and then clears the console. 
	 */
	_processCode() {
		axios.post(`/api/eval/${this.state.currentText.id}`, {
			text: this.state.currentText.text
		})
		.then(function(resp){
			let test = this.state.history.slice();
			test.push({
					id: this.state.currentText.id,
					response: resp.data,
					current: this.state.current,
					currentIndex: this.state.currentIndex,
					currentText: this.state.currentText,
				});

			// updates the history state
			this._setHistory(test);
			
			// clears the console
			this._clearConsole();

		}.bind(this))
		.catch((err) => {
			console.log(`error within the _processCode function: ${err}`);
		});
	}

	/*
	 * @name: _updateIndex
	 * @input: an updated Index
	 * @output: n/a
	 * @purpose: updates the local state's `currentIndex`
	 */
	_updateIndex(newIndex) {
		this.setState({
			currentIndex: newIndex,
		});
	}

	/*
	 * @name: _cycleHistory
	 * @input: boolean value denoting whether the user is cycling up or cycling down
	 * @output: n/a
	 * @purpose: reloads the localState to a prior input made by the user. It does this by:
	 *     1. Generate index in `.history` by checking if the user cycled 'up' or 'down'
	 *     2. Check that the new index isn't out-of-bounds in the .history array
	 *     3. Access the required information at the index, and pull them out into local variables
	 *     4. Update the local state, currentIndex in the history array, and the ._left, ._right, ._focus
	 *        for displaying the line
	 */
	_cycleHistory(upOrDown) {
		// the user cycles up
		let newHistoryIndex = upOrDown ? this.state.currentIndex - 1 : this.state.currentIndex + 1;

		if(!this.state.history[newHistoryIndex]) {
			// out of index
			return;
		}
		
		let newHistoryCurrent = this.state.history[newHistoryIndex];
		let newHistoryCurrentKey = newHistoryCurrent.current._tail.value.id;
		let newHistoryCurrentText = newHistoryCurrent.currentText;
		
		this._updateState(newHistoryCurrent.current, newHistoryCurrentText, newHistoryCurrentKey);
		this._updateIndex(newHistoryIndex);

		// resets our left, right, focus
		this._setRightLeft(newHistoryCurrent.current);
	}

	/*
	 * @name: _handleKeyDown
	 * @input: the pressed event
	 * @output: n/a
	 * @purpose: Able to direct the key action to the correct handler
	 */
	_handleKeyDown(e) {
		if (e.keyCode === 8 && this.state.consoleIsActive) { // delete
    	this._deleteCurrentLinkedList();
    }
    if (e.keyCode === 37 && this.state.consoleIsActive) { // left
    	this._determineRightLeft(true);
    }
    if (e.keyCode === 39 && this.state.consoleIsActive) { // right
    	this._determineRightLeft(false);
    }
    if (e.keyCode === 38 && this.state.consoleIsActive) { // up
    	this._cycleHistory(true);
    }
    if (e.keyCode === 40 && this.state.consoleIsActive) { // down
    	this._cycleHistory(false);
    }
    if (e.keyCode === 13 && this.state.consoleIsActive) { // enter
    	this._processCode();
    }
	}

	/*
	 * @name: _updateCurrentText
	 * @input: string
	 * @output: an object
	 * @purpose: to generate an object with a uniqueId per the character entered to be
	 *   added into the linkedList
	 */
	_updateCurrentText(text) {
		return {
			id: 'line-' + this._generateUniqueKey(),
			text: text,
		};
	}

	/*
	 * @name: _updateState
	 * @input: the local states' `.current`, `.currentText`, `.currentKey` properties
	 * @output: n/a
	 * @purpose: updates the localState with new values
	 */
	_updateState(current, currentText, currentKey) {
		this.setState({
			current: current,
			currentText: currentText,
			currentKey: currentKey,
		});
	}


	// used for initial setup
	componentDidMount() {
		if(!this.state.current.getLength()) {
			const firstSpace = ' ';
			let copyOfCurrent = this._makeCopy(this.state.current);
			let newlyAddedNode = copyOfCurrent.addNode(firstSpace, this._generateUniqueKey()); // add a space character for now

			this._updateState(copyOfCurrent, this._updateCurrentText(firstSpace), newlyAddedNode.value.id);
		}
	}

	/*
	 * @name: _setConsoleIsActive
	 * @input: click event
	 * @output: n/a
	 * @purpose: updates the `.consoleIsActive` state by tracking if the last click the
	 *   user made was in the console or not. If it's not, then no updates should occur
	 */
	_setConsoleIsActive(e) {
		if(e._targetInst._currentElement.props.id === 'console') {
			this.setState({
				consoleIsActive: true
			});
		} else {
			this.setState({
				consoleIsActive: false
			});
		}
	}


	/*
	 * @name: _addLinkedListText
	 * @input: letter
	 * @output: n/a
	 * @purpose: updates the linkedList with the new letter. It does so by:
	 *   1. Make a copy of the current linkedList instance
	 *   2. Determine to add or insert character into linkedList by checking if the
	 *      currentKey position is equal to the id of the linkedList's `._tail` id value
	 *   3. Obtain the string value for the all values in the linkedList while also setting
	 *      the new properties for the linkedList's `._left`, `._right`, and `._focus` properties
	 *   4. Update the local state with the updated linkedList
	 */
	_addLinkedListText(value) {
		let copyOfCurrent = this._makeCopy(this.state.current);
		
		// either add or insert
		let newlyAddedNode = !copyOfCurrent._length || copyOfCurrent._tail.value.id === this.state.currentKey ?
			 copyOfCurrent.addNode(value, this._generateUniqueKey()): // add node if at end
			 copyOfCurrent.insertNode(value, this.state.currentKey, this._generateUniqueKey()); // insert node if not at end

		/*
		 returns the new total text, and it also sets the current ._left, ._right, ._focus
		 properties on our existing linkedList
		*/
		let text = copyOfCurrent.returnAllRightLeft(newlyAddedNode.value.id);

		// set state for left/ right/ center
		this._setRightLeft(copyOfCurrent);

		// update the local state
		this._updateState(copyOfCurrent, this._updateCurrentText(text), newlyAddedNode.value.id);
	}

	/*
	 * @name: _deleteCurrentLinkedList
	 * @input: n/a
	 * @output: n/a
	 * @purpose: Deletes the node with the `.currentKey` id from the linkedList. It does so by:
	 *   1. Make a copy of the current linkedList instance
	 *   2. Removes the node with the `.currentKey` id and returns the node that will replace
	 *      the next `.currentKey`
	 *   3. Checks if the value for newNextNode is valid. Reason why it would be not-valid can
	 *      be found within the code below
	 *   4. Resets the `._left`, `._right`, and `._focus` properties
	 *   5. Updates the local State
	 */
	_deleteCurrentLinkedList() {
		let copyOfCurrent = this._makeCopy(this.state.current);
		let newNextNode = copyOfCurrent.removeNode(this.state.currentKey);

		/*
			checks to see if we are removing the first node (._start). If we are removing the 
			first one, then the returned node from our LinkedList would point to null; therefore,
			would not actually have a .value.id property. 
		*/
		let newNextNodeId = newNextNode !== null ? newNextNode.value.id : false;


		let text = copyOfCurrent.returnAllRightLeft(newNextNodeId);

		// set state for left/ right/ center
		this._setRightLeft(copyOfCurrent);

		// update the local state
		this._updateState(copyOfCurrent, this._updateCurrentText(text), newNextNodeId);
	}


	render() {
		return (
			<div 
				className='background' 
				tabIndex="0"
				onClick = { this._setConsoleIsActive }
				onKeyPress = { this._handleKeyPress }
				onKeyDown = { this._handleKeyDown }>
			<Console
				currentText = { this.state.currentText }
				consoleIsActive = { this.state.consoleIsActive }
				left = { this.state.left }
				right = { this.state.right }
				focus = { this.state.focus }
				history = { this.state.history }
			/>
			</div>
		)
	}
}

export default App;